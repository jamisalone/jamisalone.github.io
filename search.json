[{"title":"使用华为模拟器eNSP搭建网络自动化场景","url":"/2021/03/18/Set-up-Network-Automation-Using-Huawei-Emulator-eNSP/","content":"eNSP安装eNSP的安装过程省略，才接触eNSP时，安装会遇到需要问题，这里给出我目前能够正常使用的相关软件版本：\n\neNSP 1.3.00.100 V100R003C00 SPC100 （目前eNSP官网已经不再进行更新）\nVirtualBox Version 5.2.40 r137108\nNpcap 1.10\nWinPcap 4.1.3\n\neNSP第一次新建拓扑前，记得先注册设备：\n\n右上角找到“菜单‘，然后选中”工具“，单击”注册设备“\n\n勾选所有设备，然后点击”注册“\n\n\n\n使用VirtualBox安装自动化Ubuntu 18.04 | 20.04\n打开VirtualBox，在右上角单击”New“\n\n\n分配内存大小 — 根据电脑配置，为虚拟机分配内存，1G或2G都行（当然笔者宿主机内存较大，选择了4G），然后Next继续\n\n选择VM，选中”Create a virtual hard disk now“，单击”Create“\n\n后面的几步都选择默认勾选 — ”VDI“ + ”Dynamic allocated“\n\n分配存储大小，建议配置15G左右，分配太小可能会无法安装，单击”Create“后退回到主界面\n\n\n这时选中你刚创建的ubuntu主机，然后单击上方菜单的”Start“运行\n\n此时弹出运行界面，你需要选择你要安装的镜像的路径\n\n\n后续就会进入ubuntu的安装步骤（此处省略ubuntu后续安装步骤）\n\n\n配置Ubuntu远程客户端这里以ubuntu 18.04为例\n\n重新设置ubuntu 18.04的国内镜像源并刷新列表进行更新\n【Ubuntu】Ubuntu 18.04 LTS 更换国内源–解决终端下载速度慢的问题\n\n安装Python和相关依赖\napt-get install python -yapt-get install build-essential libssl-dev libffi-dev -yapt-get install python-pip -yapt-get install python3-pip -y\n安装paramiko和netmiko\npip install cryptographypip install paramikopip install netmikopip3 install paramikopip3 install netmiko\n\n使用Telnet来配置S3700\n设置Cloud\n\n端口增加完成后，在端口映射入端口和出端口选择不同端口（顺序不影响），然后勾选双向通道，单击”增加“，此时端口映射表会增加一对端口。\n\nCloud设置完毕后，Cloud可以与SW1进行连接了，下图为测试拓扑\n\n\n在SW1上配置telnet用户与密码（默认开启telnet）\n#aaa local-user sht1 password cipher Huawei local-user sht1 privilege level 15 local-user sht1 service-type telnet#interface Vlanif1 ip address 192.168.50.1 255.255.255.0#user-interface vty 0 4 authentication-mode aaa user privilege level 15 protocol inbound all\n在Ubuntu 18.04上配置telent01.py脚本用于批量创建vlan\n\nPython 3.6 脚本测试\n#!/usr/bin/env python3import getpassimport telnetlibHOST = &quot;192.168.50.1&quot;user = &quot;sht1&quot;password = getpass.getpass()tn = telnetlib.Telnet(HOST)tn.read_until(b&quot;Username:&quot;)tn.write(user.encode(&#x27;ascii&#x27;) + b&quot;\\n&quot;)if password:    tn.read_until(b&quot;Password:&quot;)    tn.write(password.encode(&#x27;ascii&#x27;) + b&quot;\\n&quot;)tn.write(b&quot;system\\n&quot;)tn.write(b&quot;vlan 2\\n&quot;)tn.write(b&quot;quit\\n&quot;)tn.write(b&quot;vlan 3\\n&quot;)tn.write(b&quot;quit\\n&quot;)tn.write(b&quot;vlan 4\\n&quot;)tn.write(b&quot;quit\\n&quot;)tn.write(b&quot;vlan 5\\n&quot;)tn.write(b&quot;quit\\n&quot;)tn.write(b&quot;return\\n&quot;)tn.write(b&quot;quit\\n&quot;)print(tn.read_all().decode(&#x27;ascii&#x27;))\nPython 2.7 脚本测试\n#!/usr/bin/env python2import getpassimport timeimport telnetlibHOST = &quot;192.168.50.1&quot;user = &quot;sht1&quot;password = getpass.getpass()tn = telnetlib.Telnet(HOST)tn.read_until(&quot;Username:&quot;)tn.write(user + &quot;\\n&quot;)if password:    tn.read_until(&quot;Password:&quot;)    tn.write(password + &quot;\\n&quot;)tn.write(&quot;system\\n&quot;)tn.write(&quot;vlan 6\\n&quot;)tn.write(&quot;q\\n&quot;)tn.write(&quot;vlan 7\\n&quot;)tn.write(&quot;q\\n&quot;)tn.write(&quot;vlan 8\\n&quot;)tn.write(&quot;q\\n&quot;)tn.write(&quot;vlan 9\\n&quot;)tn.write(&quot;q\\n&quot;)tn.write(&quot;vlan 10\\n&quot;)tn.write(&quot;q\\n&quot;)tn.write(&quot;return\\n&quot;)tn.write(&quot;q\\n&quot;)print tn.read_all()\n\n\n验证脚本配置是否在SW1上生效\n[SW1]display vlan The total number of vlans is : 10--------------------------------------------------------------------------------U: Up;         D: Down;         TG: Tagged;         UT: Untagged;MP: Vlan-mapping;               ST: Vlan-stacking;#: ProtocolTransparent-vlan;    *: Management-vlan;--------------------------------------------------------------------------------VID  Type    Ports                                                          --------------------------------------------------------------------------------1    common  UT:Eth0/0/1(U)     Eth0/0/2(D)     Eth0/0/3(D)     Eth0/0/4(D)                     Eth0/0/5(D)     Eth0/0/6(D)     Eth0/0/7(D)     Eth0/0/8(D)                     Eth0/0/9(D)     Eth0/0/10(D)    Eth0/0/11(D)    Eth0/0/12(D)                    Eth0/0/13(D)    Eth0/0/14(D)    Eth0/0/15(D)    Eth0/0/16(D)                    Eth0/0/17(D)    Eth0/0/18(D)    Eth0/0/19(D)    Eth0/0/20(D)                    Eth0/0/21(D)    Eth0/0/22(D)    GE0/0/1(D)      GE0/0/2(D)      2    common  3    common  4    common  5    common  6    common  7    common  8    common  9    common  10   common  VID  Status  Property      MAC-LRN Statistics Description      --------------------------------------------------------------------------------1    enable  default       enable  disable    VLAN 0001                         2    enable  default       enable  disable    VLAN 0002                         3    enable  default       enable  disable    VLAN 0003                         4    enable  default       enable  disable    VLAN 0004                         5    enable  default       enable  disable    VLAN 0005                         6    enable  default       enable  disable    VLAN 0006                         7    enable  default       enable  disable    VLAN 0007                         8    enable  default       enable  disable    VLAN 0008                         9    enable  default       enable  disable    VLAN 0009                         10   enable  default       enable  disable    VLAN 0010\n虽然配置是完成了，但是在运行脚本的过程中也遇到了问题，目前该问题还没有解决，希望有大佬出面解决\n下面是报错：\nTraceback (most recent call last):  File &quot;./telnet01.py&quot;, line 29, in &lt;module&gt;    print(tn.read_all().decode(&#x27;ascii&#x27;))  File &quot;/usr/lib/python3.6/telnetlib.py&quot;, line 333, in read_all    self.fill_rawq()  File &quot;/usr/lib/python3.6/telnetlib.py&quot;, line 524, in fill_rawq    buf = self.sock.recv(65535)ConnectionResetError: [Errno 104] Connection reset by peerTraceback (most recent call last):  File &quot;./telnet02.py&quot;, line 34, in &lt;module&gt;    print tn.read_all()  File &quot;/usr/lib/python2.7/telnetlib.py&quot;, line 385, in read_all    self.fill_rawq()  File &quot;/usr/lib/python2.7/telnetlib.py&quot;, line 576, in fill_rawq    buf = self.sock.recv(65535)socket.error: [Errno 104] Connection reset by peer\n\n","categories":["Network Automation","eNSP Series"],"tags":["Python","Telnet","eNSP","Network Automation网络自动化"]},{"title":"使用Paramiko配置MSTP场景","url":"/2021/03/18/Configure-MSTP-with-Paramiko/","content":"测试Paramiko配置交换机\n拓扑\n\n\n\n在SW1上配置SSH Server、SSH登录用户和密码\n创建密钥对\n[SW1]rsa local-key-pair create The key name will be: SW1_HostThe range of public key size is (512 ~ 2048). NOTES: If the key modulus is greater than 512,        it will take a few minutes.Input the bits in the modulus[default = 512]:2048Generating keys.............++++++++++++..........++++++++++++.++++++++....++++++++\n\n由于ubuntu 20.04是比较新的版本，不再支持1023bit以下长度的密钥，所以直接配置1024或者2048长度的密钥\n\n使能Stelnet服务器\nstelnet server enable\n配置SSH\n\n配置SSH用户登录界面\nuser-interface vty 0 4 authentication-mode aaa user privilege level 15 protocol inbound ssh#\n配置SSH用户\nssh user shtssh user sht authentication-type passwordssh user sht service-type stelnet#\n\n如果SSH用户使用password认证( authentication-type = password | rsa | password-rsa )，则只需要在SSH服务器端生成本地RSA密钥。如果SSH用户使用RSA认证，则在服务器端和客户端都需要生成本地RSA密钥对，并且服务器端和客户端都需要将对方的公钥配置到本地。\n\n配置对SSH用户进行password认证\naaa local-user sht password cipher Huawei local-user sht privilege level 15 local-user sht service-type ssh#\n\n\n配置管理VLAN\n\n创建管理VLAN100\n#vlan 100 management-vlan#interface Vlanif100 ip address 192.168.50.1 255.255.255.0#\n配置Hybrid接口（关于为什么配置Hybrid口，可以参考网络基础回顾[1]）\n#interface Ethernet0/0/1 port hybrid pvid vlan 100 port hybrid untagged vlan 100#\n\n\n\nUbuntu 20.04用SSH远程登录SW1，验证SW1的SSH配置是否生效\n在ubuntu 20.04上使用ssh sht@192.168.50.1，出现报错：\n$ ssh sht@192.168.50.1**Unable to negotiate with** 192.168.50.1 port 22: **no matching key exchange method found.** **Their offer: diffie-hellman-group1-sha1,diffie-hellman-group-exchange-sha1**\n\n\n问题描述：\n如果客户端和服务器无法就一组共同的参数达成一致，那么连接将失败。OpenSSH (7.0及以上版本)会产生类似这样的错误信息，Ubuntu20.04使用OpenSSH 8.2。在这种情况下，客户端和服务器无法就密钥交换算法达成一致，服务器只提供（即该实验中的SW1）两个方法diffie-hellman-group1-sha1和diffie-hellman-group-exchange-sha1，OpenSSH支持这两种密钥交换方法，但是默认不启用，因为这两种方法版本较久，比较弱(weak)，在所谓的Logjam攻击的理论范围内。所以我们需要在客户端启用较弱的方法。\n$ ssh -VOpenSSH_8.2p1 Ubuntu-4ubuntu0.1, OpenSSL 1.1.1f  31 Mar 2020\n解决方案：\n来源：\nOpenSSH: Legacy Options\n$ ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 sht@192.168.50.1\n\n\n+ — 在客户端默认集合中增加该交换算法而不是替换默认算法\n-o — 选项\n-KexAlgorithms — 密钥交换方法-用来生成每个连接的密钥；\n\n\n\n\n使用ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 sht@192.168.50.1后，成功连接上SW1\n$ ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 sht@192.168.50.1The authenticity of host &#x27;192.168.50.1 (192.168.50.1)&#x27; can&#x27;t be established.RSA key fingerprint is SHA256:BqJmFBxfyFuobgWlC7MmLlpjfu1UjsyhnLbdd/GIVc8.Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;192.168.50.1&#x27; (RSA) to the list of known hosts.sht@192.168.50.1&#x27;s password: Info: The max number of VTY users is 5, and the number      of current VTY users on line is 1.      The current login time is 2021-03-02 19:12:58.&lt;SW1&gt;sysEnter system view, return user view with Ctrl+Z.[SW1]\n\n配置paramiko_test.py对SW1进行配置\n编写脚本paramiko_test.py\nimport paramikoimport timeip_address = &quot;192.168.50.1&quot;username = &quot;sht&quot;password = &quot;Huawei&quot;ssh_client = paramiko.SSHClient()ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # not recommended for production but fine for labsssh_client.connect(hostname = ip_address, username = username, password = password)print(&quot;Successful connection&quot;, ip_address)remote_connection = ssh_client.invoke_shell()remote_connection.send(&quot;system\\n&quot;)# creation of vlansfor n in range (2,21):    print(&quot;Creating VLAN &quot; + str(n))    remote_connection.send(&quot;vlan &quot; + str(n) +  &quot;\\n&quot;)    remote_connection.send(&quot;description VLAN &quot; + str(n) +  &quot;\\n&quot;)    time.sleep(0.5) # wait half of secondremote_connection.send(&quot;return\\n&quot;)time.sleep(1)output = remote_connection.recv(65535)print(output.decode(&#x27;ascii&#x27;))ssh_client.close\n\nparamiko_test.py脚本解释\n第一部分\nip_address = &quot;192.168.50.1&quot;username = &quot;sht&quot;password = &quot;Huawei&quot;ssh_client = paramiko.SSHClient()ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # not recommended for production but fine for labsssh_client.connect(hostname = ip_address, username = username, password = password)\n\n\nParamiko官方文档给出的paramiko.client.SSHClient类的描述为：\n与SSH服务器建立SSH会话的高级表示，该类封装了Transport，Channel和SFTPClient类来处理好认证和打开通道(channel)。\nSSHClient的典型使用方式为：\nclient = SSHClient()client.load_system_host_keys()client.connect(&#x27;ssh.example.com&#x27;)# stdin, stdout, stderr = client.exec_command(&#x27;ls -l&#x27;) 暂时不用了解\n\n使用SSHClient()创建SSH客户端，上传脚本的一端作为服务端，然后调用load_system_host_keys(filename = None)读取主机密钥，参数filename默认为None，则会尝试从用户的本地 “known hosts”文件中读取密钥；再调用connect()与hostname 为ssh.example.com的服务器建立连接，服务器的主机密钥会与系统主机密钥 (load_system_host_keys) 和任何本地主机密钥 (load_host_keys) 对照检查，如果在这两组主机密钥中都找不到服务器的主机名，则使用缺失主机密钥策略 (set_missing_host_key_policy)，默认策略是决绝连接并报错SSHException；\n\nset_missing_host_key_policy(paramiko.AutoAddPolicy( ))\n\nset_missing_host_key_policy(policy) 设置连接到未知主机密钥的服务器时要使用的策略；policy即要设置的策略类，可以设置为RejectPolicy(默认)、AutoAddPolicy和WarningPolicy等；如果不配置该策略，默认是拒绝与服务器连接的。\n将paramiko.AutoAddPolicy() 设为参数，用于自动将主机名和新的主机密钥添加到本地HostKeys对象中，并将该对信息保存，该方法由SSHClient调用；\n不仅接受了来自未知主机密钥的服务器提供的公钥，建立了连接，还会将主机名与对应的密钥保存到HostKeys对象中，后面再与该服务器进行连接，就可以使用load_system_host_keys或load_host_keys方法了\n\n\n\n\n第二部分\nremote_connection = ssh_client.invoke_shell()remote_connection.send(&quot;system\\n&quot;)# creation of vlansfor n in range (2,21):    print(&quot;Creating VLAN &quot; + str(n))    remote_connection.send(&quot;vlan &quot; + str(n) +  &quot;\\n&quot;)    remote_connection.send(&quot;description VLAN &quot; + str(n) +  &quot;\\n&quot;)    time.sleep(0.5) # wait half of secondremote_connection.send(&quot;return\\n&quot;)\n\n\nremote_connection = ssh_client.invoke_shell()\n由于SSHClient类封装了Channel类，类似socket，使用invoke_shell()后，客户端会在SSH服务器上启动一个交互式shell会话，即用通道类(Channel)新建通道(channel)，并按要求的终端类型和大小连接到一个伪终端\nssh_client是SSHClient类的对象，调用SSHClient的方法invoke_shell()后，创建了remote_connection这个通道类(Channel)的通道\n\n\nremote_connection.send()\n通道(Channel)类中的send()用于传输数据\n这里remote_connection是通道(channel)，调用send()方法向SSH服务器发送数据\n\n\n\n\n第三部分\ntime.sleep(1)output = remote_connection.recv(65535)print(output.decode(&#x27;ascii&#x27;))ssh_client.close\n\n\ntime.sleep(1)\n\noutput = remote_connection.recv(65535) 中，remote_connection通道使用recv(65535)设置读取Bytes的最大值；recv()如果返回字节的长度为0时，通道流就会被关闭；\n\noutput.decode(&#39;ascii&#39;) ，recv()的返回值为字节型字符串，将返回值赋值给output变量，然后在Python 3中使用decode(&#39;ascii&#39;)将字节型字符串解析为ascii编码，帮助输出美观的内容；\n如果不适用decode(&#39;ascii&#39;)，输出如下：\n\n\nssh_client.close 关闭ssh_client；close直接关闭SSHClient类\n\n\n\n\n\n\n将配置推送到(pull to)设备\n上传到SW1【运行代码】\n\n\n在SW1上检查脚本配置是否生效\n\n脚本成功远程配置SW1上的vlans。\n\n\n配置MSTP场景拓扑规划与设备基础配置\n拓扑与规划\n\n\n在MST1中，SwitchA作为根，阻塞SwitchD的Ethernet0/0/2接口\n在MST2中，SwitchB作为根，阻塞SwitchC的Ethernet0/0/2接口\n\n\n交换机基础配置\nrsa local-key-pair create **2048**#stelnet server enable#user-interface vty 0 4 authentication-mode aaa user privilege level 15 protocol inbound ssh#aaa local-user sht password cipher Huawei local-user sht privilege level 15 local-user sht service-type ssh#ssh user shtssh user sht authentication-type passwordssh user sht service-type stelnet#vlan 100 management-vlan#interface Vlanif100 ip address 192.168.50.x 255.255.255.0\n\n\nSwitchA | SwitchB\n#interface Ethernet0/0/1 port link-type trunk port trunk allow-pass vlan 100#interface Ethernet0/0/2 port link-type trunk port trunk allow-pass vlan 100#interface Ethernet0/0/3 port link-type trunk port trunk allow-pass vlan 100#\nSwitchC | SwitchD\n#interface Ethernet0/0/1 port link-type trunk port trunk allow-pass vlan 100#interface Ethernet0/0/2 port link-type trunk port trunk allow-pass vlan 100#\n\n\n验证Ubuntu与各交换机的连通性\n$ ssh-keygen -f &quot;/home/sht/.ssh/known_hosts&quot; -R &quot;192.168.50.100&quot;# $ ssh-keygen -f &quot;/home/sht/.ssh/known_hosts&quot; -R &quot;192.168.50.101&quot;# $ ssh-keygen -f &quot;/home/sht/.ssh/known_hosts&quot; -R &quot;192.168.50.102&quot;# $ ssh-keygen -f &quot;/home/sht/.ssh/known_hosts&quot; -R &quot;192.168.50.103&quot;\n\n如果都能成功登录，则说明Ubuntu与交换机连通性良好，并且可以进行远程登录；\n\n\n编写脚本并上传到设备脚本总览\n配置内容总览\n\n\n脚本总览\n#!/usr/bin/env python3import paramikoimport timeSwitchA = &#123;    &#x27;ip&#x27;: &#x27;192.168.50.100&#x27;,    &#x27;username&#x27;: &#x27;sht&#x27;,    &#x27;password&#x27;: &#x27;Huawei&#x27;,    &#x27;is_root&#x27;: True,    &#x27;primary_instances&#x27;: [&#x27;1&#x27;],    &#x27;secondary_instances&#x27;: [&#x27;2&#x27;],    &#x27;cost_change_interfaces&#x27;: [],    &#x27;trunk_interfaces&#x27;: [&#x27;e0/0/1&#x27;, &#x27;e0/0/2&#x27;],    &#x27;access_interfaces&#x27;: [],    &#x27;root_interfaces&#x27;:[&#x27;e0/0/2&#x27;],&#125;SwitchB = &#123;    &#x27;ip&#x27;: &#x27;192.168.50.101&#x27;,    &#x27;username&#x27;: &#x27;sht&#x27;,    &#x27;password&#x27;: &#x27;Huawei&#x27;,    &#x27;is_root&#x27;: True,    &#x27;primary_instances&#x27;: [&#x27;2&#x27;],    &#x27;secondary_instances&#x27;: [&#x27;1&#x27;],    &#x27;cost_change_interfaces&#x27;: [],    &#x27;trunk_interfaces&#x27;: [&#x27;e0/0/1&#x27;, &#x27;e0/0/2&#x27;],    &#x27;access_interfaces&#x27;: [],     &#x27;root_interfaces&#x27;:[&#x27;e0/0/2&#x27;],&#125;SwitchC = &#123;    &#x27;ip&#x27;: &#x27;192.168.50.102&#x27;,    &#x27;username&#x27;: &#x27;sht&#x27;,    &#x27;password&#x27;: &#x27;Huawei&#x27;,    &#x27;is_root&#x27;: False,    &#x27;primary_instances&#x27;: [&#x27;1&#x27;],    &#x27;secondary_instances&#x27;: [&#x27;2&#x27;],    &#x27;cost_change_interfaces&#x27;: [&#x27;e0/0/2&#x27;],    &#x27;trunk_interfaces&#x27;: [&#x27;e0/0/1&#x27;, &#x27;e0/0/2&#x27;],    &#x27;access_interfaces&#x27;: [&#x27;e0/0/3&#x27;],    &#x27;root_interfaces&#x27;:[],&#125;SwitchD = &#123;    &#x27;ip&#x27;: &#x27;192.168.50.103&#x27;,    &#x27;username&#x27;: &#x27;sht&#x27;,    &#x27;password&#x27;: &#x27;Huawei&#x27;,    &#x27;is_root&#x27;: False,    &#x27;primary_instances&#x27;: [&#x27;2&#x27;],    &#x27;secondary_instances&#x27;: [&#x27;1&#x27;],    &#x27;cost_change_interfaces&#x27;: [&#x27;e0/0/2&#x27;],    &#x27;trunk_interfaces&#x27;: [&#x27;e0/0/1&#x27;, &#x27;e0/0/2&#x27;],    &#x27;access_interfaces&#x27;: [&#x27;e0/0/3&#x27;],    &#x27;root_interfaces&#x27;:[],&#125;def paramiko_SSH_Command(switch):\t&#x27;&#x27;&#x27; Start &#x27;&#x27;&#x27;\tssh_client = paramiko.SSHClient()\tssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # not recommended for production but fine for labs\tssh_client.connect(hostname = switch[&#x27;ip&#x27;], username = switch[&#x27;username&#x27;], password = switch[&#x27;password&#x27;])\tprint(&quot;               &quot;*3)\tprint(&quot;===============&quot;*3)\tprint(&quot;               &quot;*3)\tprint(&quot;Successful connection&quot;, switch[&#x27;ip&#x27;])\tremote_connection = ssh_client.invoke_shell()\tremote_connection.send(&quot;system\\n&quot;)\t&#x27;&#x27;&#x27; Some Configuration Functions &#x27;&#x27;&#x27;\tcommon_Configuration(remote_connection, switch[&#x27;cost_change_interfaces&#x27;], switch[&#x27;secondary_instances&#x27;])\tif switch[&#x27;is_root&#x27;]:\t\troot_PriSec(remote_connection, switch[&#x27;primary_instances&#x27;], switch[&#x27;secondary_instances&#x27;])\tedged_port_bpdu_protection(remote_connection, switch[&#x27;access_interfaces&#x27;])\tif switch[&#x27;root_interfaces&#x27;]:\t\troot_protection(remote_connection, switch[&#x27;root_interfaces&#x27;])\tconf_trunk_interfaces(remote_connection, switch[&#x27;trunk_interfaces&#x27;])\tif switch == SwitchC:\t\tconf_access_interfaces(remote_connection, switch[&#x27;access_interfaces&#x27;], 2)\telif switch == SwitchD:\t\tconf_access_interfaces(remote_connection, switch[&#x27;access_interfaces&#x27;], 11)\t&#x27;&#x27;&#x27; End &#x27;&#x27;&#x27;\tremote_connection.send(&quot;return\\n&quot;)\tremote_connection.send(&quot;save\\n&quot;)\tremote_connection.send(&quot;y\\n&quot;)\tremote_connection.send(&quot;\\n&quot;)\ttime.sleep(5)\toutput = remote_connection.recv(65535)\tprint(output.decode(&#x27;ascii&#x27;))\tssh_client.closedef common_Configuration(remote_connection, cost_change_interfaces, secondary_instances):\t# Stp region_configuration\tprint(&quot;Configuring stp region_configuration ...&quot;)\tregion_configurations = [&#x27;stp region-configuration\\n&#x27;, &#x27;region-name RG1\\n&#x27;, &#x27;instance 1 vlan 2 to 10\\n&#x27;,\t\t&#x27;instance 2 vlan 11 to 20\\n&#x27;, &#x27;active region-configuration\\n&#x27;, &#x27;quit\\n&#x27;]\tfor region_configuration in region_configurations:\t\tremote_connection.send(region_configuration)\t# Stp cost computing methods\tprint(&quot;Configuring stp pathcost-standard legacy ...&quot;)\tremote_connection.send(&quot;stp pathcost-standard legacy\\n&quot;)\t# Stp interface cost\tprint(&quot;Configuring interface cost ...&quot;)\tif cost_change_interfaces:\t\tfor secondary_instance in secondary_instances:\t\t\tfor cost_change_interface in cost_change_interfaces:\t\t\t\tremote_connection.send(&quot;interface &quot; + cost_change_interface + &quot;\\n&quot;)\t\t\t\tremote_connection.send(&quot;stp instance &quot; + secondary_instance +&quot; cost 20000\\n&quot;)\t\t\t\tremote_connection.send(&quot;quit\\n&quot;)\t# STP enable\tprint(&quot;Creating VLAN and Enabling STP ...&quot;)\tremote_connection.send(&quot;vlan batch 2 to 20\\n&quot;)\tremote_connection.send(&quot;stp enable\\n&quot;)def conf_trunk_interfaces(remote_connection, trunk_interfaces):\tprint(&quot;Configuring trunk interfaces ...&quot;)\tfor trunk_interface in trunk_interfaces:\t\tremote_connection.send(&quot;interface &quot; + trunk_interface + &quot;\\n&quot;)\t\tremote_connection.send(&quot;port link-type trunk\\n&quot;)\t\tremote_connection.send(&quot;port trunk allow-pass vlan 2 to 20\\n&quot;)\t\tremote_connection.send(&quot;quit\\n&quot;)def conf_access_interfaces(remote_connection, access_interfaces, access_vlan):\tprint(&quot;Configuring access interfaces ...&quot;)\tfor access_interface in access_interfaces:\t\tremote_connection.send(&quot;interface &quot; + access_interface + &quot;\\n&quot;)\t\tremote_connection.send(&quot;port link-type access\\n&quot;)\t\tremote_connection.send(&quot;port default vlan &quot; + str(access_vlan) + &quot;\\n&quot;)\t\tremote_connection.send(&quot;quit\\n&quot;)def root_protection(remote_connection, interfaces):\tprint(&quot;Configuring stp protection ...&quot;)\tfor interface in interfaces:\t\tremote_connection.send(&quot;interface &quot; + interface + &quot;\\n&quot;)\t\tremote_connection.send(&quot;stp root-protection\\n&quot;)\t\tremote_connection.send(&quot;quit\\n&quot;)def edged_port_bpdu_protection(remote_connection, interfaces):\tprint(&quot;Configuring edged-port and bpdu protection ...&quot;)\tif interfaces:\t\tfor interface in interfaces:\t\t\tremote_connection.send(&quot;interface &quot; + interface + &quot;\\n&quot;)\t\t\tremote_connection.send(&quot;stp edged-port enable\\n&quot;)\t\t\tremote_connection.send(&quot;quit\\n&quot;)\t\tremote_connection.send(&quot;stp bpdu-protection\\n&quot;)def root_PriSec(remote_connection, primary_instances, secondary_instances):\t# Stp primary root\tprint(&quot;Configuring primary root ...&quot;)\tif primary_instances:\t\tfor primary_instance in primary_instances:\t\t\tremote_connection.send(&quot;stp instance &quot; + primary_instance + &quot; root primary\\n&quot;)\telse:\t\tprint(&quot;No primary root configuration.&quot;)\t# Stp secondary root\tprint(&quot;Configuring secondary root ...&quot;)\tif secondary_instances:\t\tfor secondary_instance in secondary_instances:\t\t\tremote_connection.send(&quot;stp instance &quot; + secondary_instance + &quot; root secondary\\n&quot;)\telse:\t\tprint(&quot;No secondary root configuration.&quot;)if __name__==&quot;__main__&quot;:\tparamiko_SSH_Command(SwitchA)\tparamiko_SSH_Command(SwitchB)\tparamiko_SSH_Command(SwitchC)\tparamiko_SSH_Command(SwitchD)\n\n将配置推送到设备\n\n脚本解析\n使用字典(dict)来规范交换机的配置参数\n接入层与汇聚层在某些配置上不同，而字典中的键是相同的\n为了后续调用不同方法配置不同配置，没有相应配置的key都设置了空值，函数在被调用时先判断是否为空值；如果为空，则不进行特定功能的配置；如果不为空，则根据键(key)来调用值(value)，进行相应功能的配置；\n\n\n使用paramiko_SSH_Command(switch)作为一个总方法来调用其余对应各类配置的方法\n四台交换机的stp region-configuraion配置相同，并且都需要创建相同的VLAN然后使能STP(默认MSTP模式)；除此以外，STP开销都使用华为特有的计算方法；用一个函数common_Configuration封装；\n配置access接口时，汇聚层的SwitchA和SwitchB不需要配置，所以调用conf_access_interfaces(remote_connection, access_interfaces, access_vlan) 时，先判断switch对象是否为SwitchC或SwitchD；根据不同Switch指定的接口PVID也不同，比如SwitchC负责偶数vlan下的主机，而SwitchD负责奇数vlan下的主机，通过匹配SwitchC还是SwitchD，来配置不同的PVID；\n类似于边缘端口的配置edged_port_bpdu_protection，不受一些特殊条件限制 (如不同Switch配置不同PVID)，只是每个交换机上需要配置的接口不同，使能边缘端口命令没有其他参数的参与，就可以先判断需要配置边缘端口的列表是否为空，为空则不进行配置，不为空则for循环调用待配置接口列表，各个接口挨个配置；同理，MSTP根和备用根的配置，也只在SwitchA和SwitchB上进行，通过判断是否为空，就可以避免在SwitchC和SwitchD上配置，然后进一步根据设备字典中的instance相关字段，只在汇聚层设备上调用root_PriSec。\n\n\n\n验证配置\n\n\n查看端口状态和端口保护类型\n\nSwitchA\n[SwitchA]display stp brief  MSTID  Port                        Role  STP State     Protection...   1    Ethernet0/0/1               DESI  FORWARDING      NONE   1    Ethernet0/0/2               DESI  FORWARDING      ROOT   2    Ethernet0/0/1               ROOT  FORWARDING      NONE   2    Ethernet0/0/2               DESI  FORWARDING      ROOT\n\n\n在MSTI1中，SwitchA为根桥，则Ethernet0/0/1和Ethernet0/0/2成为指定端口；\n在MSTI2中，SwitchA的Ethernet0/0/1成为指定端口，Ethernet0/0/2成为根端口；\n\n\nSwitchB\n[SwitchB]display stp brief  MSTID  Port                        Role  STP State     Protection...   1    Ethernet0/0/1               ROOT  FORWARDING      NONE   1    Ethernet0/0/2               DESI  FORWARDING      ROOT   2    Ethernet0/0/1               DESI  FORWARDING      NONE   2    Ethernet0/0/2               DESI  FORWARDING      ROOT\n\n\n在MSTI2中，SwitchB为根桥，则Ethernet0/0/1和Ethernet0/0/2成为指定端口；\n在MSTI1中，SwitchB的Ethernet0/0/2成为指定端口，Ethernet0/0/1成为根端口；\n\n\nSwitchC\n&lt;SwitchC&gt;display stp interface Ethernet 0/0/1 brief  MSTID  Port                        Role  STP State     Protection..   1    Ethernet0/0/1               ROOT  FORWARDING      NONE   2    Ethernet0/0/1               ROOT  FORWARDING      NONE&lt;SwitchC&gt;display stp interface Ethernet 0/0/2 brief MSTID  Port                        Role  STP State     Protection...   1    Ethernet0/0/2               DESI  FORWARDING      NONE   2    Ethernet0/0/2               ALTE  DISCARDING      NONE\n\n\n在MSTI1和MSTI2中，Ethernet0/0/1都是根端口；\n在MST1中，Ethernet0/0/2为指定端口；在MST2中，Ethernet0/0/1被阻塞；\n\n\nSwitchD\n&lt;SwitchD&gt;display stp interface e0/0/1 brief  MSTID  Port                        Role  STP State     Protection...   1    Ethernet0/0/1               ROOT  FORWARDING      NONE   2    Ethernet0/0/1               ROOT  FORWARDING      NONE&lt;SwitchD&gt;display stp interface e0/0/2 brief MSTID  Port                        Role  STP State     Protection...   1    Ethernet0/0/2               ALTE  DISCARDING      NONE   2    Ethernet0/0/2               DESI  FORWARDING      NONE\n\n\n在MSTI1和MSTI2中，Ethernet0/0/1都是根端口；\n在MST2中，Ethernet0/0/2为指定端口；在MST1中，Ethernet0/0/1被阻塞；\n\n\n\n\n\n参考\nParamiko documentation\n华为S3700配置文档\n\n写在最后\n本文主要在记录自己学习paramiko的过程，旨在提高自己对paramiko的认识和编程能力，规范性不一定强，只是一种探索方式，可能并不能作为一种可靠的学习参考；\n文中有很多内容是转译和自己的所思所想，可能存在多处错误，也拜托大家能够指出错误和不足之处。\n\n","categories":["Network Automation","eNSP Series"],"tags":["Python","eNSP","Network Automation网络自动化","SSH","Paramiko"]}]